# 데이터베이스 인덱스

### 인덱스?

DB 테이블에서 필요한 데이터를 빠르게 찾기 위해서 인덱스를 사용할 수 있다. 인덱스를 생성하면, 특정 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 주소와 함께 저장된다. 쉽게 비유하자면 책에 있는 목차(색인)이라고 할 수 있다. SQL 튜닝에서 중요한 Index에 대해서 알아보자

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a3c249a3-5fa6-42e0-8370-f5500a829874/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220118T165342Z&X-Amz-Expires=86400&X-Amz-Signature=67430f4322557f37d7dd4dd1ee5c031695af955674e2e187b3edcc2f5854c8bf&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

### 인덱스를 사용하는 이유

인덱스의 가장 큰 특징은 데이터들이 정렬되어있다는 점이다. 덕분에 다양한 장점이 있는데, 다음과 같다.

- Where
    - 인덱스가 없다면 Where절 사용시 레코드를 처음부터 끝까지 다 읽는 Full Table Scan이 일어나게된다. 하지만 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있다.
- Order by
    - 인덱스가 없다면 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스 이용시 바로 가져오면 된다.
- Min, Max
    - MIN값과 MAX값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기에 FULL TABE SCAN으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.

### 인덱스의 자료구조

**Hash Table**

대부분의 Index는 B+Tree 자료구조를 이용하고 있다. 하지만 탐색능력만 따지면 O(1)시간의 Hash Table구조를 사용할 수 있을텐데 이유가 무엇일까? **해쉬테이블을** DB 인덱스로 사용할 수 없는 이유는 다음과 같다.

가장 큰 문제로 “***우리는 DB에서 등호(=) 뿐 아니라 부등호(<, >)도 사용할 수 있다”***  모든 값이 정렬되어 있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 수 없다. 

> MySQL InnoDB에서는 메모리 버퍼 풀에서 레코드 검색을 위한 [어댑티브 해시 인덱스](https://tech.kakao.com/2016/04/07/innodb-adaptive-hash-index/)로 사용
> 

**Array**

배열의 문제는 간단하다. 탐색이 O(1)이라 해도 삽입 삭제시 O(N)시간이 걸리기 때문이다. 또 

**데이터 수정이 일어날때도 퀵 정렬, 병합 정렬 등 배열 자료구조에서 O(N*logN) 시간으로 재정렬을 이루어야 한다는 점도 있다.**

> 참고로 B-tree의 삽입, 삭제는 트리의 높이(h)에 따른 O(h)의 시간 복잡도를 가지는데, 이는 logN보다 훨씬 작은 값이다.
> 

**결론적으로 DB 인덱스로 B-Tree가 가장 적합한 이유들을 정리하면 아래와 같다.**

1. **항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.**
2. **참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.**
3. **데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.**

### 인덱스의 종류

인덱스에는 **클러스터드 인덱스 (Clustered Index)** 와 **논-클러스터드 인덱스 (Non-Clustered Index)** 2가지 종류가 존재한다.

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f6039c3e-a2f4-4e83-b6ee-c21e4c96b345/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220118%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220118T165353Z&X-Amz-Expires=86400&X-Amz-Signature=184bab3533ad128d92704cf9a1c5dd8a101d67c6c8996e1ea0c15ceae8eae4af&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

### 클러스터드 인덱스

- 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다.
- 데이터 삽입, 삭제 발생 시 **순서를 유지**하기 위해 **데이터를 재정렬**해야한다.
- 한 개의 릴레이션에 **하나의 인덱스만 생성 가능**

### 넌클러스터드 인덱스

- 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
- 데이터를 검색하기 위해서는 먼저 인덱스를 검색하여 실제 데이터 위치를 확인해야 하므로 **클러스터드 인덱스에 비해 검색 속도가 떨어진다.**
- 한 개의 릴레이션에 여러 인덱스를 만들 수 있다.

### 인덱스의 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

### 인덱스의 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### 인덱스의 관리

DBMS는 index를 항상 최신의 **정렬된 상태로 유지**해야 원하는 값을 빠르게 탐색할 수 있다.

그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해줘야하며, 그에 따른 오버헤드가 발생한다.

- INSERT : 새로운 데이터에 대한 인덱스를 추가함
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 

만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 **오히려 성능이 떨어지게** 될 것이다.

### 인덱스는 언제 써야 하는가?

보통 인덱스는 한 테이블당 3~5개가 적당하다. 큰 결정 조건으로는 아래 4가지 기준이 있다.

- **카디널리티 (Cardinality)**
    - **카디널리티가 높으면(↑) 인덱스 설정에 좋은 컬럼이다. (인덱스를 통해 불필요한 데이터의 대부분을 걸러낼 수 있음.)**카디널리티가 높다 = 한 컬럼이 갖고 있는 값의 중복도가 낮음. (= 값들이 대부분 다른 값을 가짐.)카디널리티가 낮다 = 한 컬럼이 갖고 있는 값의 중복도가 높음. (= 값들이 거의 같은 값을 가짐 )
- **선택도 (Selectivity)**
    
    **선택도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다. (일반적으로 5~10%가 적당함.)**선택도가 높다 = 한 컬럼이 갖고 있는 값 하나로 여러 row가 찾아진다.선택도가 낮다 = 한 컬럼이 갖고 있는 값 하나로 적은 row가 찾아진다.
    
    > 선택도 계산법 (= 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100)
    ex) 10개의 데이터에서 고유한 학번(grade) 컬럼,
     2명씩 같은 이름(name) 컬럼,
     5명씩 같은 나이(age) 컬럼인 경우
    ① 학번(grade) 컬럼 선택도: 1 / 10 = 10%
    ② 이름(name) 컬럼 선택도: 2 / 10 = 20%
    ③ 나이(age) 컬럼 선택도: 5 / 10 = 50%
    > 
- **조회 활용도**
    - **조회 활용도가 높으면(↑) 인덱스 설정에 좋은 컬럼이다.**해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값.(`WHERE`의 대상 컬럼으로 많이 활용되는지로 판단하면 된다.)
- **수정 빈도**
    - **수정 빈도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다.**인덱스도 테이블이기 때문에, 인덱스로 지정된 컬럼의 값이 바뀌게 되면 인덱스 테이블도 새롭게 갱신되어야 하기 때문.



## 참고자료

- hash table index, b-tree index
    
    [데이터베이스 인덱스는 왜 'B-Tree'를 선택하였는가](https://helloinyong.tistory.com/296)
    
- 인덱스란?
    
    [](https://mangkyu.tistory.com/96)
    
- DB 인덱스
    
    [[DB] 데이터베이스 인덱스(Index) 란 무엇인가?](https://coding-factory.tistory.com/746)
    
    [[면접 대비] 데이터베이스 - 인덱스](https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4)
    
- 인덱스 종류, 인덱스 사용이유
    
    [효과적인 DB index 설정하기](https://velog.io/@jwpark06/%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-DB-index-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0)
    
    [](https://yurimkoo.github.io/db/2020/03/14/db-index.html)