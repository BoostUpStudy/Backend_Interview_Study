# 가상 메모리

# ⭐️ 등장 배경

기존 메모리 관리는 하나의 프로그램 전체를 실제 물리 메모리에 올리는 방식을 사용했다.

하지만 메모리에 많은 프로세스들을 올리고자 하는데 물리 메모리에 전부 올리기에는 한계가 존재한다. (메모리 용량 부족, 페이지 교체 성능 이슈)

컴퓨터는 폰 노이만 구조이기 때문에 사용할 코드는 반드시 메모리에 있어야해서 코드를 물리 메모리에 전부 올린다는 발상이었지만 프로그램을 사용하는데 그 때마다 필요한 코드들만 있어도 실행이 되기 때문에 불필요하게 전체의 프로그램이 메모리에 올라와 있지 않아도 된다는 점에서 아이디어를 얻었다고 한다. 

따라서 프로그램 전체가 아닌 **필요한 일부분만 실제 메모리에 올리는 기법**인 가상 메모리를 사용하게 되었다.

이런 방법을 사용하면 

1. 더 많은 프로그램들을 동시에 메모리에 올려 작업할 수 있다.
2. 한 번에 올리는 소스 양이 적기 때문에 Disk와 Memory간 I/O 작업 속도가 빨라진다.

등의 장점을 얻을 수 있다.

![1](https://user-images.githubusercontent.com/71375034/146891002-cbf4dd43-fdb6-486b-94fb-1ece3a950401.png)

# ⭐️ 아이디어

프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 변경한다.

- Virtual address : 프로세스가 참조하는 주소
    - 디스크의 페이지 파일에 저장된다.
        - 페이지 교체할 때 이 디스크 swap영역에서 페이지를 가져오는 것
- Physical address : 실제 메모리 주소

CPU는 가상 메모리를 다루는데, 실제 물리 주소 접근시 MMU(Memory Management Unit)를 통해 물리 메모리에 접근한다.

- MMU : CPU에서 코드 실행 시 가상 메모리 주소를 물리 주소 값으로 변환해주는 하드웨어 장치

# ⭐️ Paging

## 등장 배경

메모리에 프로세스를 연속 할당할 때 발생하는 **외부 단편화**를 해결하기 위해 사용한다.

![2](https://user-images.githubusercontent.com/71375034/146891057-ef64f446-61c6-4437-88bc-2bbcc52e7289.png)

## 개념

- page : 가상 메모리 공간의 최소 단위
- frame : 물리 메모리 공간의 최소 단위

크기가 동일한 page로 가상 메모리 공간과 이에 매칭되는 물리 메모리 공간을 관리한다.

이 page들은 실제 들어있는 데이터 양과 관계없이 모두 고정 크기를 가진다.

이 때, 고정된 각 크기는 시스템에 따라 다르다.

- 크기가 작을 수록 내부 단편화가 해결되지만, 페이지 개수 증가로 인해 페이지 단위의 I/O가 증가한다.

각 프로세스의 PCB에는 page Table 구조체를 가리키는 주소가 있는데 이 테이블에는 가상/물리 주소의 매핑 정보가 담겨있고 이를 활용한다.

![3](https://user-images.githubusercontent.com/71375034/146891094-dda06870-a5e8-436f-8d32-3d0ce5a6816c.png)

## 원리

가상 주소와 물리 주소를 동일한 크기로 자르고 어디에 배치되는지 기록하며 배치한다면?? 자투리 공간이 발생하지 않고 딱 맞게 배치된다.

![4](https://user-images.githubusercontent.com/71375034/146891129-9a109c1d-d1d3-4f4d-b53b-c9e496564ed4.png)

이렇게 하면 프로세스를 연속할당 할 필요가 없기 때문에 **외부단편화 문제를 해결**할 수 있다.

고정 크기라는 것 때문에 **내부단편화가 발생**하긴 하지만 외부단편화로 인해 발생하는 낭비 공간이 더 크기 때문에 이를 감수하더라도 페이징을 사용하는 것이 이득이다.

그런데 생각해보면 프로세스는 **차례대로 읽어 수행**되는 linear address가 필요한데 paging 기법처럼 프로세스가 조각으로 나뉘어져 따로 놀고 있는데 어떻게 연속적으로 실행될까??

→ Page Table을 이용

# ⭐️ Page Table

- 프로세스 생성시 PCB에 페이지 테이블 정보가 생성된다.
- 프로세스 구동시, page table의 base 주소가 별도 레지스터에 저장되고, CPU가 가상 주소 접근시 MMU는 page table의 base 주소에 접근해 물리 주소를 얻는다.
    - 이 때, 페이지들이 연달아 실행될 수 있도록 순서에 맞는 물리 주소 위치를 찾아준다.
    - 즉, linear하게 수행시킬 수 있다.

![5](https://user-images.githubusercontent.com/71375034/146891152-c8b09099-7f0d-44da-b90e-bdd9e0d63fd6.png)

기본적으로 배열처럼 인덱스가 페이지 번호를 가리키고 그 배열에 담고 있는 숫자가 매핑할 프레임 번호를 뜻한다.

## 페이지 크기와 가상 주소 구성

CPU에 의해서 생성되는 주소를 가상 주소, RAM에 실질적으로 로드되는 주소를 물리 주소라고 했는데 위 예시에서 0,1,2,3 등 말고 실제 이 주소들은 어떻게 구성되어 있는지를 알아보자.

가상 주소는 페이지 번호(p)와 페이지 오프셋(d)으로 구성된다.

- p : 매핑을 위해 page와 frame은 번호를 갖는데, 페이지 순서에 해당하는 숫자를 의미한다.
    - but, 덩어리인 page만으로 정확한 주소를 표기할 수 없기 때문에 오프셋을 추가로 사용한다.
- d : page내의 번호를 의미한다.
    - 하나의 페이지가 4KB라 가정하면 page 0의 주소는 0 ~ 2^12까지이다.

가상 주소 구하기

os가 32bit이고, 페이지 크기가 4KB라고 가정할 때

2^32 / 2^12 = 2^20

즉, CPU는 한 번에 2^20개의 페이지 번호를 구분할 수 있다.

따라서 32bit라고 할 때 앞의 20bit는 페이지 번호를 의미하고, 뒤 12bit는 오프셋을 의미한다.

## **가상 주소 → 물리 주소 변환 FLOW**

![6](https://user-images.githubusercontent.com/71375034/146891181-ca2fb2b8-e8c8-433f-92c8-5e2a69f0894c.png)

- p : 페이지 번호
- f : 프레임 번호
- d : 페이지 오프셋

d를 제외한 나머지 비트에 있는 page 번호를 page table에서 검색하면 frame 번호가 나온다.

page와 frame 크기는 똑같기 때문에 오프셋은 동일하다.

ex) 

PageSize = 1KB

PageTable = 1 3 5 4

**가상 주소 3000의 물리 주소는??**

1KB는 10bit로 표현 가능하고 3000은 101110111000(2) 이다.

따라서 d(오프셋)는 뒤의 10자리 (1110111000(2))이고 p(페이지 번호)는 남은 앞에 2개 (10(2))이다. 따라서 p는 2이기 때문에 두 번째 인덱스인 5 → 101(2)와 d를 붙인 1011110111000(2)가 물리 주소이다.

위와 같은 과정으로 물리 주소를 참조하지만 매번 페이지 테이블을 이용하는 것은 매우 비효율적이기 때문에 TLB를 이용한다.

# ⭐️ 예상 질문 리스트

1. 가상 메모리를 사용하는 이유가 뭘까요?
2. 가상 메모리를 설명해주세요.
3. 페이징 기법에 대해서 설명해주세요.
    1. 페이지 크기는 어떻게 정해지나요?
4. 페이징 기법에서 페이지 테이블을 사용하는 이유가 뭘까요?
5. 가상 주소는 어떻게 구성되어 있나요?
6. 가상 주소로 어떻게 물리 주소를 알아낼 수 있나요?

# ⭐️ 참고

[Interview_Question_for_Beginner/OS at master · JaeYeopHan/Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)
