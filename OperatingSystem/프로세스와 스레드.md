# ⭐️ 프로세스

프로그램은 **메모리에 올라오지 않은 정적인 코드 덩어리** 라고하는데 이 프로그램이 실제 메모리에 올라가 실행되고 있으면 프로세스라고 부른다.

즉, OS로부터 시스템 자원을 할당받는 작업의 단위이다.

![0](https://user-images.githubusercontent.com/71375034/147556665-08ba6cef-8ce5-4857-bedc-3aadd1df7117.png)

## 프로세스 특징

프로세스는 최소 1개의 스레드를 가지고 있고 각각 독립된 메모리 영역을 할당받는다.

독립되어있기 때문에 별도의 주소 공간에서 실행되며, 일반적인 방법으로는 다른 프로세스에 접근할 수 없다.(IPC를 사용하면 접근 가능)

### 프로세스의 메모리 구조

- Code 영역
    - 컴파일된 코드 자체가 저장된다.
    - 프로세스가 사용하는 기계어로 된 프로그램 명령들이 위치해 있다.
- Data 영역
    - 전역변수, 정적변수, 배열, 구조체 등이 저장된다.
    - 자세하게 말하면 **초기화 된 데이터는 Data영역**에, **초기화 되지 않은 데이터는 BSS 영역**에 저장된다.
        - 이 둘을 구분하는 이유??
        - 초기화 되지 않는 변수는 프로그램이 실행될 때 영역만 잡아주면 되고 그 값을 프로그램에 저장하고 있을 필요가 없으나 초기화된 변수는 그 값도 프로그램에 저장하고 있어야하기 때문에 구분한다.
    - 프로그램이 실행될 때 생성되고 프로그램이 종료되면 반환된다.
- Heap 영역
    - 필요에 의해 동적으로 메모리를 할당 하고자 할 때 사용하는 메모리 영역
    - 메모리 주소 값에 의해서만 참조되고 사용된다.
- Stack 영역
    - 프로그램이 자동으로 사용하는 **임시 메모리** 영역
    - 지역변수, 매개변수, 리턴 값 등 잠시 사용되었다가 사라지는 데이터
    - 함수 호출 시 생성되고, 함수가 끝나면 반환된다.
    - 이 스택 사이즈는 프로세스가 메모리에 로드 될 때 고정되어 할당된다. 따라서 런타임에 사이즈를 변경할 수 없다.

## 프로세스 상태

![1](https://user-images.githubusercontent.com/71375034/147556701-93cc7274-6b86-4588-b3a9-e292a4ab6ae8.png)

- New : 프로세스가 생성되었을 때
- Ready : 프로세스가 프로세서에게 할당 받기를 기다릴 때
- Running :  프로세스가 실행 상태일 때
- Waiting(Blocked) : 프로세스가 어떤 이벤트가 발생하기를 기다릴 때
- Suspended : 프로세스의 실행이 중지되었을 때
    - 메모리를 강제로 뺏긴 상태(디스크 swap-out)
    - Ready에서 swap-out이면 Suspended Ready, Blocked에서 swap-out이면 Suspended Block
- Terminated : 프로세스의 실행이 종료되었을 때

프로세스는 위 6단계에 따라 **프로세스 큐(Job, Ready, Device)**에 각각 올라가있고 큐에 올리는 일은 **프로세스 스케줄러가 담당**한다.

### Ready와 Waiting의 차이

- I/O 작업이나 기타 이벤트로 인한 상태 변화에는 Running → Waiting → Ready → Running 의 순서로 변한다.
    - 즉, 준비가 다 끝나지 않은 프로세스가 준비를 끝내기위해서 대기 중인 상태
- 프로세스 스케줄링에 의한 상태 변화(time out, interrupt)에는 Running → Ready → Running 의 순서로 변한다.
    - 즉, 준비가 다 끝난 프로세스가 실행되기를 기다리는 상태

### Context Switching → 프로세스의 상태를 바꿔주는 것

## 프로세스 Queue와 스케줄러

프로세스의 큐는 Job, Ready, Device가 존재한다.

- Job Queue : 시스템 상의 모든 프로세스들을 의미
- Ready Queue : 메모리에 올라가 있고 실행을 기다리는 프로세스들을 의미
- Device Queue : I/O 작업을 위해 기다리고 있는 프로세스들을 의미

![2](https://user-images.githubusercontent.com/71375034/147556710-0f3c70c5-d2c5-4d48-988d-0a98525047fc.png)

이러한 큐에 어떤 것을 올릴지 결정하는 것이 스케줄러이다.

- Long-Term Scheduler(장기 스케줄러)
    - Job Scheduler라고도 불리며 **Ready Queue에 어떤 것들을 올려야하는지 결정**하는 스케줄러이다.
        - 즉, **디스크**에 있는 프로그램을 **메모리**로 올려 프로세스로 만드는 작업
    - 속도는 빠르지 않아도 괜찮다.
    - 멀티 프로그래밍의 정도를 제어
        - 그 이유는 얘가 메모리에 프로세스를 올려주기 때문에 I/O-bound 프로세스와 CPU-bound 프로세스를 적절히 섞어서 올려줘야 한다.
    - 상태 변경 : New → Ready(in memory)
- Short-Term Scheduler(단기 스케줄러)
    - 우리들이 알고 있는 CPU Scheduler 라고 불리며 **어떤 프로세스에게 CPU 자원을 할당할 것인지를 결정**하는 스케줄러이다.
        - 즉, **메모리**에 올라와 있는 프로세스를 **CPU에게 할당**
    - CPU 자원 할당은 매우 짧은 시간 단위로 반복되기 때문에 속도가 빨라야한다.
    - 상태 변경 : Ready → Running
- Medium-Term Scheduler(중기 스케줄러)
    - 실행하기에 필요한 자원이 부족한 프로세스들 중 **어떤 프로세스를 Swap-out 하여 Disk에 저장할지, 어떤 프로세스를 Swap-in 해야하는지를 결정**해주는 스케줄러이다.
        - 즉, **메모리**에 너무 많은 프로세스가 동시에 올라가있다면 **디스크**로 내보내는 작업
    - 상태 변경 : Ready → Suspended
        - Terminated가 아니다.
        - 누군가 다시 재개시켜줘야(swap-in해줘야) 다시 Ready로 돌아갈 수 있다.

## PCB(Process Control Block)

특정 프로세스에 대한 중요한 정보를 저장하고 있는 OS의 자료구조이다.

프로세스 생성과 동시에 고유한 PCB가 생성되고 프로세스 전환시(인터럽트나 시스템콜)에 PCB에 기록하고 사용한다.

- PCB에 저장되는 정보들 중 중요한 것들
    - PID : 프로세스 식별 번호
    - 상태
    - CPU 스케줄링 정보
    - TCB가 PCB를 참조
        - 레지스터
        - PC(Program Counter) : 프로세스가 다음에 실행할 명령어의 주소

![3](https://user-images.githubusercontent.com/71375034/147556728-82639f5b-eb16-4240-b7b4-d8f69fcbbf2a.png)

- 추가 내용(같이 고민해볼 점)
    
    스케줄링에는 Context Switching 시간까지 포함되어 있다.
    
    따라서 PCB의 저장과 복원이 오래걸리면 그만큼 작업을 수행할 수 있는 시간이 짧아지는 것
    
    따라서 **PCB의 저장과 복원은 H/W로 구현해서 작업 효율을 최대한 늘린다고 한다.**
    
    근데 OS의 자료구조인데 하드웨어..? 잘 모르겠다.
    

# ⭐️ 스레드

멀티 스레드와 혼용해서 설명

프로세스의 수행 경로

즉, 프로세스가 할당받은 자원을 이용하는 실행의 단위(흐름)

ex) 메신저 프로그램에서 “내가 입력”, “상대방이 입력한 것을 출력” 등 하나씩이 실행 단위이다.

![4](https://user-images.githubusercontent.com/71375034/147556767-ca652e01-478c-4ad7-8713-c3aee2565b71.png)

## 스레드가 필요한 이유

결론은 프로세스만으로 요구 사항을 충족하기 쉽지 않아서이다.

예를 들어서 메신저 프로그램일 때, 내가 입력한 것을 출력해줌과 동시에 상대방이 입력한 것도 출력해야한다.

이 때, 싱글 프로세스를 사용한다면 키보드 입력을 기다릴 때 상대방으로부터 온 메시지를 받을 수 없다.

왜냐면 하나의 path만 가지고 있기 때문

![5](https://user-images.githubusercontent.com/71375034/147556778-257ccd6d-e3d4-4482-986f-af34eec3d54a.png)

대충 이런 느낌이다.(프로세스는 기본적으로 하나의 스레드를 가지고 있음)

따라서 프로세스를 추가로 생성해야하는데 문제는 프로세스 자체가 독립된 자원을 할당 받기 때문에 서로 공유하지 않아서 관련되지 않은 실행 path를 가진다.

![6](https://user-images.githubusercontent.com/71375034/147556789-7ce8de36-e1a5-494c-b9bb-6d4464af08de.png)

그럼 뭐다?? 서로 통신(IPC) 해야하는데 프로그램이 커지고 시간이 지날수록 비효율적이다.(PCB 추가, 메모리 추가, Context Switching 등)

- IPC는 커널을 껴서 통신해야한다.

그래서 하나의 프로세스에 여러 path를 만들고 자원을 공유하는 멀티 스레드를 사용하는 것(다수의 path가 필요한 것 뿐이기 때문에 굳이 자원 낭비를 하지 말자!)

## 스레드 특징

스레드는 프로세스와 다르게 Stack만 따로 할당 받고 Code, Data, Heap 영역은 공유한다.

정확히는 프로세스와 동일하게 실행 상태를 갖고 Register와 Stack을 독립적으로 할당받는다.

### Stack과 Register를 독립적으로 할당받는 이유??

- stack
    - 스레드는 하나의 독립적인 실행단위이기 때문에 각각 독립적인 stack을 가진다.(독립적인 함수 호출)
    - 즉, 함수 호출 시 인자, 리턴 값 지역 변수 등을 독립적으로 가지기 위해서
- register
    - 프로세스와 똑같이 CPU를 할당받고, 선점당할 수 있다.
    - 따라서 Context Switching이 발생하게 되므로 실행하고 있는 코드의 지점을 저장하는 PC 등을 스레드마다 독립적으로 할당해야 한다.

## 장점

1. 사용자에 대한 응답성 증가
    - 하나의 스레드가 waiting인 동안 다른 스레드가 실행되어 다른 작업을 빨리 처리할 수 있기 때문
2. 프로세스의 자원과 메모리 공유
    - 하나의 같은 주소 공간에서 여러 개의 스레드를 실행해 병렬성, 성능향상을 가질 수 있다.
3. 경제성
    - 한 프로세스의 자원을 공유하기 때문에 프로세스끼리 Context Switching하는 것보다 스레드끼리 하는 것이 오버헤드가 적다.
        - 스레드가 Context Switching 오버헤드가 작은 이유 : 스레드는 Stack, Register만 하면 되고 RAM과 CPU 사이의 캐시를 사용 가능하지만 프로세스는 캐시까지 초기화되어버린다.
4. 다중 프로세서(CPU) 구조 활용
    - 멀티 스레드를 통해 병렬로 수행할 수 있기 때문

# ⭐️ 멀티 프로세스

하나의 응용 프로그램을 여러 개의 프로세스로 구성해 각 프로세스가 하나의 작업을 처리하도록 하는 것

![7](https://user-images.githubusercontent.com/71375034/147556802-917713a0-289e-4172-9407-acfaa83322a8.png)

## 장단점

- 장점
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
- 단점
    - Context Switching에서의 오버헤드 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
    - 프로세스 사이의 어렵고 복잡한 통신 기법(IPC) 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

# ⭐️ 멀티 스레드

하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.

대부분 많은 운영체제들이 멀티 스레딩을 기본으로 하고 있다.

![8](https://user-images.githubusercontent.com/71375034/147556818-41b74afb-11ff-4e9e-be6f-05404330f520.png)

![9](https://user-images.githubusercontent.com/71375034/147556827-6ea6430d-185e-4c80-89a4-9b455ba8a9e9.png)

ex)

워드에서 키보드 입력을 기다리고, 주기적으로 저장하고, 타이핑 에러 체크하고 등을 전부 동시에 한다.

저 3개를 프로세스로 할 순 있는데 매우 비효율적

따라서 

워드 → 프로세스 하나

키보드 입력 → 스레드

주기적 저장 → 스레드

타이핑 에러 체크 → 스레드

## 장단점

- 장점
    - 시스템 자원 소모 감소 (자원의 효율성 증대)
    - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    - 시스템 처리량 증가 (처리 비용 감소)
    - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
    - 스레드 사이의 작업량이 작아 Context Switching이 빠르다.
    - 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
    - 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
- 단점
    - 주의 깊은 설계가 필요하다.
    - 디버깅이 까다롭다.
    - 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
    - 다른 프로세스에서 스레드를 제어할 수 없다. (즉, 프로세스 밖에서 스레드 각각을 제어할 수 없다.)
    - 멀티 스레드의 경우 자원 공유의 문제가 발생한다. (동기화 문제)
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다

## 멀티 스레드 모델(조금 deep 한 내용)

모델을 설명하기 전에 **User Thread**와 **Kernel Thread**에 대해 알아야한다.

- User Thread
    - 사용자가 관리하는 스레드
    - 스레드 전환시 커널 모드 권한이 필요없고 빠르게 만들고 관리할 수 있다.(커널 스레드보다 오버헤드가 적음 → Context Switch가 없다.(사용자 영역 스레드에서 행동하기 때문 → 메모리 상에 저장해놓나??))
    - 사용자 영역에서 하기 때문에 운영체제에 의존적이지 않다.(커널이 제공해주지 않고 라이브러리를 활용)
    - 하지만 일반적인 OS에서는 대부분의 시스템 호출이 차단되고 다중 처리를 활용할 수 없다.(I/O 작업 등에 의해 블록되면 전체 스레드가 멈춘다.)
- Kernel Thread
    - 운영체제가 직접 커널에서 제공하고 관리하는 스레드
    - 하나의 프로세스는 적어도 하나의 커널 스레드를 가진다.
    - 프로세스의 스레드들을 한꺼번에 디스패치할 수 있기 때문에 멀티 프로세서 환경에서 좋다.
    - 다른 스레드가 입출력 작업이 끝날 때까지 기다릴 필요가 없다.
    - 안정성과 다양한 기능을 제공
    - 하지만 스케줄링과 동기화를 위해 커널을 호출하는데 무겁고 오래걸린다. 즉, 사용자모드에서 커널모드로 전환이 빈번하게 이루어지면 성능 저하가 발생한다. 또한 구현하기 어렵고 자원을 더 많이 소비한다.

### 1. Many-to-One Model

![10](https://user-images.githubusercontent.com/71375034/147556844-b5f47204-7744-4207-99be-9592389bfe2b.png)

- 하나의 Kernel Thread가 다수의 User Thread를 처리하는 구조(=User Thread만 사용했다고 보면 됨)
- User Thread를 처리하던 중 시스템 콜에 의해 blocking되면 **전체 프로세스가 막히게 된다.**

### 2. One-to-One Model

![11](https://user-images.githubusercontent.com/71375034/147556853-4c4d6dbf-4609-4fa4-b340-8b5a2c49481c.png)

- User Thread 한 개 당 Kernel Thread를 대응시켜 작업하는 구조
- 과도한 Kernel Thread 생성 문제가 있다.

### 3. Many-to-Many Model

![12](https://user-images.githubusercontent.com/71375034/147556866-f1401ad1-ce2b-48ac-91fe-138fb5dd5473.png)

- 1,2를 어느정도 보완한 모델로 다수의 User Thread를 다수의 Kernel Thread가 처리하는 구조
- Kernel Thread의 숫자는 User Thread의 숫자보다 같거나 작아야한다.

### 4. Two-Level Model

![13](https://user-images.githubusercontent.com/71375034/147556877-a2aad1d6-3f2e-47b8-ada6-0ab92e25362c.png)

- 최종적으로 보안된 모델로 2+3을 합친 구조이다.
- 중요한 작업은 One-to-One 처럼, 나머지는 Many-to-Many 처럼 처리함으로써 혹시나 있을 중요한 작업에서의 기다림 현상을 줄일 수 있다.
    

# ⭐️ 참고

프로세스와 스레드
[https://github.com/Songwonseok/CS-Study/blob/main/OS/프로세스vs스레드.md](https://github.com/Songwonseok/CS-Study/blob/main/OS/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4vs%EC%8A%A4%EB%A0%88%EB%93%9C.md)
[https://coder-in-war.tistory.com/entry/OS-00-프로세스와-스레드의-차이?category=994187](https://coder-in-war.tistory.com/entry/OS-00-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4?category=994187)

프로세스
[https://baked-corn.tistory.com/5?category=718232](https://baked-corn.tistory.com/5?category=718232)
스레드
[https://baked-corn.tistory.com/6?category=718232](https://baked-corn.tistory.com/6?category=718232)

OS 튜토리얼
[https://www.tutorialspoint.com/operating_system/index.htm](https://www.tutorialspoint.com/operating_system/index.htm)

프로세스 상태, 큐, 스케줄러
[https://kosaf04pyh.tistory.com/190](https://kosaf04pyh.tistory.com/190)

멀티 스레드 모델
[https://www.crocus.co.kr/1255](https://www.crocus.co.kr/1255)
