# 함수형 프로그래밍

### 프로그래밍 패러다임

> 프로그래머에게 프로그래밍의 관점을 갖게 하고 코드를 어떻게 작성할 지 결정하는 역할을 한다.

### 명령형 프로그래밍

> 무엇을 할 것인지 나타내기 보다 **어떻게** 할 것인지를 설명하는 방식

- **절차지향 프로그래밍**

  수행되어야 할 순차적인 처리 과정을 포함하는 방식 (C, C++)

- **객체지향 프로그래밍**

  객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#)

### 선언형 프로그래밍

> 어떻게 할 건지를 나타내기 보다 **무엇**을 할 건지를 설명하는 방식

- 함수형 프로그래밍

  순수함수를 조합하고 소프트웨어를 만드는 방식
  
  </br>

# 함수형 프로그래밍

### 정의

> 거의 모든 것을 순수함수로 나누어 문제를 해결하는 기법으로, 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다.

**부수 효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 잇으며, 참조 투명성을 지킬 수 있다.**

</br>

### **부수효과 (side-effect)**

- 변수의 값이 변경
- 자료 구조를 제자리에서 수정
- 객체의 필드값을 설정
- 예외나 오류가 발생하며 실행이 중단됨
- 콘솔 또는 파일 I/O가 발생함



### **순수함수**

> 어떤 함수에 동일한 인자를 주었을 때 항상 같은 값을 리턴하는 함수 + 외부의 상태를 변경하지 않는 함수

**부수효과들을 제거한 함수를 순수함수라고 부르며 함수형 프로그래밍에서 사용하는 함수는 순수함수 이다.**

**효과**

- 함수 자체가 독립적이며 부수효과가 없기 때문에 Thread에 안정성을 보장받을 수 있다.
- 병렬처리를 동기화 없이 진행할 수 있다.



### **1급 객체**

다음과 같은 것들이 가능한 객체를 의미한다.

- 변수나 데이터 구조 안에 담을 수 있다.
- 파라미터로 전달할 수 있다.
- 반호나값으로 사용할 수 있다.
- 할당에 사용된 이름과 무관핫게 고유한 구별이 가능하다.

**함수형 프로그래밍에서는 함수는 1급 객체로 취급받기 때문에 함수를 파라미터로 넘기는 등의 작업이 가능하다.**



### **참조 투명성**

**함수형 프로그래밍에서는 동일한 인자에 대해 항상 동일한 결과를 반환해야 한다. ⇒ 외부의 영향을 받지 않는다.**

참조 투명성을 통해 기존의 값은 병경되지 않고 유지된다. (Immutable Data)



### **고차 함수**

- 함수에 함수를 파라미터로 전달하는 함수
- 반환값으로 함수를 반환하는 함수



### 장점

- 높은 수준의 추상화를 제공한다.
- 함수 단위의 코드 재사용이 수월하다.
- 불변성을 지향하기 때문에 동작을 예측하기 쉬워진다.

### 단점

- 순수함수를 구현하기 위해 코드의 가독성이 떨어질 수 있다.
- 함수형 프로그래밍에서는 반복을 for문이 아닌 재귀를 통해 이뤄지는데 재귀적 코드 스타일은 무한루프에 빠질 수 있다.
- 순수함수를 쓰는건 쉽지만 조합하는 것은 어려울 수 있다.

</br>

## 클로저

### 정의

> 생성될 당시의 환경을 기억하는 함수를 말한다. 환경이라고 하면 스코프체인 자체를 말하는데 스코프체인을 통해 접근 할 수 있는 변수나 함수가 스코프가 해제되어야 할 시점에도 사라지지 않는다.



**내부함수**

자바스크립트는 함수 안에서 또 다른 함수를 선언할 수 있다. 함수 안에 선언된 함수를 내부함수 라고 한다.

내부함수는 내부함수를 포함하고 있는 외부함수의 문맥(context)에 접근할 수 있을 뿐만 아니라 **외부함수가 종료된 이후에도 내부 함수를 통해 접근할 수 있다**.





**스코프**

> 변수에 접근할 수 있는 **범위**

- 전역 스코프

  - 전역에 선언되어 있어 어느 곳에서든지 해당 변수에 접근할 수 있다

- 지역 스코프

  - 해당 지역에서만 접근할 수 있어 지역을 벗어난 곳에서 접근할 수 없다
  - 함수 스코프 : 함수가 생성될 때마다 새로운 스코프가 형성됨
  - 블록 스코프 : 블록 `{}` 이 생성될 때마다 새로운 스코프가 형성됨
  - 자바스크립트는 원래 함수 스코프를 따랐는데 `let`, `const`의 등장으로 블록 스코프를 형성하는 것도 가능해졌다.
  - [함수 스코프 vs 블록 스코프](https://velog.io/@fromzoo/%ED%95%A8%EC%88%98%EC%8A%A4%EC%BD%94%ED%94%84-vs-%EB%B8%94%EB%A1%9D%EC%8A%A4%EC%BD%94%ED%94%84)

  

**문맥(context)**

> this 키워드 값이 무엇인지를 나타낸다.⇒ **함수가 속해있는 객체**가 무엇인지 의미한다.

- 만약 함수가 전역 스코프에서 선언되었다면, 이때의 문맥(context)는 global이다.

클로저를 이용해 카운터를 구현해보며 이해해보자.

```jsx
function createCounter = () => {
	let count = 0;

	return function() {
		return (count += 1);
	}
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
```

`createCounter` 함수는 안에서 `count + 1` 를 반환하는 함수를 선언하고 리턴해준다. 이 때 내부에 선언된 함수는 외부의 지역변수 `count`에 접근할 수 있다.

`createCounter` 함수를 호출하고 난 뒤 스코프가 해제되어야 하는 시점인데 외부함수의 지역변수를 사용하는 내부함수가 `counter1, 2` 에 각각 할당되어있기 때문에 해제되지 않고 외부함수 스코프에 접근할 수 있다.

counter1과 counter2가 생성되었을 때의 환경을 각각 가지고 있기 때문에 실행했을 때 결과가 다르게 독립적으로 동작하는 것을 볼 수 있다.

**객체보다 클로저의 활용에서 은닉화가 더 극대화 된다.** 함수 내부의 변수는 외부에서 접근할 방법이 전혀 없기 때문이다.

</br>

## 커링

여러개의 파라미터를 가진 함수를 호출 할 경우, 파라미터의 수보다 적은 파라미터를 인자로 받으면 누락된 파라미터를 다음 파라미터로 받는 기법

```jsx
function sum(a, b) {
	return a + b;
}
```

`sum` 함수가 동작하려면 a, b를 모두 전달 받아야 한다. 이를 커링함수로 수정하면 다음과 같다.

```jsx
function adder(a) {
	return function(b) {
		return a + b;
	}
}

console.log(adder(5)(1)); // 6

const add5 = adder(5);
console.log(add5(1)); // 6	
```

어떤 함수를 호출할 때 매개 변수가 항상 비슷할 때 유용하게 사용할 수 있는 기법이다. 매번 새로운 인자를 전달하지 않아도 바깥에 있는 함수가 인자를 전달하고, 새로운 인자는 내부 함수가 받게 된다.

`add5` 는 클로저를 이용한 것이고 `adder` 함수에 5를 인자로 넣었을 때의 환경을 기억하는 내부함수이다.

굳이 `add5` 함수를 선언하지 않고 `adder(5)(1)` 이런식으로 바로 호출할 수 있다.

</br>

# 객체지향 vs 함수형

- 객체지향은 함수의 동작부를 캡슐화하여 코드를 이해할 수 있게 한다.

  **클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어진다**. 따라서 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있다. 특히 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라진다.

  객체가 일급객체

</br>

- 함수형은 동작부를 최소화해서 코드의 이해를 돕는다.

  **값의 연산 및 결과 도출 중심으로 코드 작성이 이루어진다**. 함수 내부에서 인자로 받은 값을 별도로 저장하거나 하지 않고, 간결한 과정으로 처리하고 매핑하는데에 주 목적을 둔다.

  함수가 일급객체

</br>

다형성은 강하게 비결합된 시스템을 만들어주기 때문에 바람직하다. 설계된 구조의 경계 사이에서 종속성이 역전될 수 있게끔 해준다. 다른 모듈들에 영향을 주지 않으면서도 수정이 가능하게 된다.

⇒ 유지 보수와 개발이 편한 시스템

</br>

참조 투명성은 시스템을 예상 가능하게 만들어주기 때문에 바람직하다. 스레드 경쟁상태같은 동시성 관련 문제도 현저리 줄여준다.

⇒ 내부 상태를 바꿀수 없다는 성질은 시스템을 이해하기 쉽고 개발하기 쉽게 만든다.

</br>

결국 두가지 패러다임 모두 개발을 편하고 쉽게 하기 위한 패러다임.

**두 가지 패러다임은 서로 대비되는 개념이 아니고 구현하려는 기능에 맞도록 적절한 방법을 골라서 사용하면 된다.** 한가지 패러다임을 선택했다고 해서 다른 쪽을 배제하려는 자세는 오히려 시스템의 구조를 약하게 만든다.

</br>

### ⇒ 적절히 상황에 맞게 잘 쓰자!


</br>


### 참고

[함수형 프로그래밍이란](https://mangkyu.tistory.com/111)

[함수형프로그래밍 - 클로저](https://velog.io/@rnjsrntkd95/%ED%81%B4%EB%A1%9C%EC%A0%80Closure-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

[스코프란](https://medium.com/@su_bak/javascript-%EC%8A%A4%EC%BD%94%ED%94%84-scope-%EB%9E%80-bc761cba1023)

[클로저 - 생활코딩](https://opentutorials.org/course/743/6544)

[클로저와 객체](https://ui.toast.com/weekly-pick/ko_20160701)

[기존의 사고 방식을 깨부수는 함수형 사고](https://evan-moon.github.io/2019/12/15/about-functional-thinking/)
